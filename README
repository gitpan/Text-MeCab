NAME
    Text::MeCab - Alternate Interface To libmecab

SYNOPSIS
      use Text::MeCab;
      my $mecab = Text::MeCab->new({
        rcfile             => $rcfile,
        dicdir             => $dicdir,
        userdic            => $userdic,
        lattice_level      => $lattice_level,
        all_morphs         => $all_morphs,
        output_format_type => $output_format_type,
        partial            => $partial,
        node_format        => $node_format,
        unk_format         => $unk_format,
        bos_format         => $bos_format,
        eos_format         => $eos_format,
        input_buffer_size  => $input_buffer_size,
        allocate_sentence  => $allocate_sentence,
        nbest              => $nbest,
        theta              => $theta,
      });

      for (my $node = $mecab->parse($text); $node; $node = $node->next) {
         # See perdoc for Text::MeCab::Node for list of methods
         print $node->surface, "\n";
      }

      # use constants
      use Text::MeCab qw(:all);
      use Text::MeCab qw(MECAB_NOR_NODE);

      # want to use a command line arguments?
      my $mecab = Text::MeCab->new("--userdic=/foo/bar/baz", "-P");

      # check what mecab version we compiled against?
      print "Compiled with ", &Text::MeCab::MECAB_VERSION, "\n";

DESCRIPTION
    libmecab (http://mecab.sourceforge.ne.jp) already has a perl interface
    built with it, so why a new module? I just feel that while a subtle
    difference, making the perl interface through a tied hash is just...
    weird.

    So Text::MeCab gives you a more natural, Perl-ish way to access
    libmecab!

    WARNING: Please note that this module is primarily targetted for
    libmecab >= 0.90, so if things seem to be broken and your libmecab
    version is below 0.90, then you might want to consider upgrading
    libmecab first.

Text::MeCab AND SCOPING
    [NOTE: The memory management issue has been changed since 0.09]

    libmecab's default behavior is such that when you analyze a text and get
    a node back, that node is tied to the mecab "tagger" object that
    performed the analysis. Therefore, when that tagger is destroyed via
    mecab_destroy(), all nodes that are associated to it are freed as well.

    Text::MeCab defaults to the same behavior, so the following won't work:

      sub get_mecab_node {
         my $mecab = Text::MeCab->new;
         my $node  = $mecab->parse($_[0]);
         return $node;
      }

      my $node = get_mecab_node($text);

    By the time get_mecab_node() returns, the Text::MeCab object is
    DESTROY'ed, and so is $node (actually, the object exists, but it will
    complain when you try to access the node's internals, because the C
    struct that was there has already been freed).

    In such cases, use the dclone() method. This will copy the *entire* node
    structure and create a new Text::MeCab::Node::Cloned instance.

      sub get_mecab_node {
         my $mecab = Text::MeCab->new;
         my $node  = $mecab->parse($_[0]);
         return $node->dclone();
      }

    The returned Text::MeCab::Node::Cloned object is exactly the same as
    Text::MeCab::Node object on the surface. It just uses a different but
    very similar C struct underneath. It is blessed into a different
    namespace only because we need to use a different memory management
    strategy.

    Do be aware of the memory issue. You WILL use up twice as much memory.

    Also please note that if you try the first example, accessing the node
    *WILL* result in a segfault. This is *NOT* a bug: it's a feature :)
    While it is possible to control the memory management such that
    accessing a field in a node that has already expired results in a legal
    croak(), we do not go to the length to ensure this, because it will
    result in a performance penalty.

    Just remember that unless you dclone() a node, then you are NOT allowed
    to access it when the original tagger goes out scope:

       {
           my $mecab = Text::MeCab->new;
           $node = $mecab->parse(...);
       }

       $node->surface; # segfault!!!!

    Always remember to dclone() before doing this!

METHODS
  new HASHREF | LIST
    Creates a new Text::MeCab instance.

    You can either specify a hashref and use named parameters, or you can
    use the exact command line arguments that the mecab command accepts.

    Below is the list of accepted named options. See the man page for mecab
    for details about each option.

    rcfile
    dicdir
    lattice_level
    all_morphs
    output_format_type
    partial
    node_format
    unk_format
    bos_format
    eos_format
    input_buffer_size
    allocate_sentence
    nbest
    theta

  parse SCALAR
    Parses the given text via mecab, and returns a Text::MeCab::Node object.

SEE ALSO
    http://mecab.sourceforge.ne.jp

AUTHOR
    (c) 2006 Daisuke Maki <dmaki@cpan.org> All rights reserved.

